/**
 * @fileOverview Firestore Security Rules for PlacementPro.
 *
 * Core Philosophy:
 * This ruleset enforces a user-ownership model for user profiles and resources.
 * Mentors, Bookings, Reviews, and Bootcamps are publicly accessible for reading but have restricted write access.
 * Administrative privileges are managed through a dedicated `/roles_admin` collection, using the "existence over content" pattern.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles; access is restricted to the user themselves.
 * - /mentors/{mentorId}: Stores mentor profiles; publicly readable, but write access is restricted.
 * - /bookings/{bookingId}: Stores booking information; publicly readable, but write access is restricted.
 * - /reviews/{reviewId}: Stores reviews for mentors; publicly readable, but write access is restricted.
 * - /resources/{resourceId}: Stores community resources; publicly readable, write access restricted to the resource creator.
 * - /bootcamps/{bootcampId}: Stores bootcamp information; publicly readable, write access is restricted.
 * - /roles_admin/{userId}: Indicates admin privileges; write access is limited to admins.
 *
 * Key Security Decisions:
 * - User listing is disallowed to protect user privacy.
 * - Public read access is granted for mentors, bookings, reviews, resources, and bootcamps to allow open discovery.
 * - Resources require an `authorId` field to enforce owner-only writes.
 * - No schema validation is performed beyond authorization-critical fields, adhering to the prototyping philosophy.
 *
 * Denormalization for Authorization:
 * - The `authorId` field is used in the `/resources/{resourceId}` collection to directly enforce ownership without requiring additional reads.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profiles.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' can create their own profile.
     * @allow (get, update, delete) User with ID 'user123' can read, update, and delete their own profile.
     * @deny (create) User with ID 'user456' cannot create a profile for 'user123'.
     * @deny (get, update, delete) User with ID 'user456' cannot read, update, or delete the profile of 'user123'.
     * @principle Enforces document ownership for all operations on user profiles.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // User listing is disallowed

      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to mentor profiles.
     * @path /mentors/{mentorId}
     * @allow (get, list) Any user can read mentor profiles.
     * @deny (create, update, delete) Only specific logic should allow modification of mentor profiles (TODO).
     * @principle Public read access with restricted write access.
     */
    match /mentors/{mentorId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add logic for mentor profile management
    }

    /**
     * @description Controls access to booking information.
     * @path /bookings/{bookingId}
     * @allow (get, list) Any user can read booking information.
     * @deny (create, update, delete) Only specific logic should allow modification of booking information (TODO).
     * @principle Public read access with restricted write access.
     */
    match /bookings/{bookingId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add logic for booking management
    }

    /**
     * @description Controls access to reviews for mentors.
     * @path /reviews/{reviewId}
     * @allow (get, list) Any user can read reviews.
     * @deny (create, update, delete) Only specific logic should allow modification of reviews (TODO).
     * @principle Public read access with restricted write access.
     */
    match /reviews/{reviewId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add logic for review management
    }

    /**
     * @description Controls access to resources in the community library.
     * @path /resources/{resourceId}
     * @allow (get, list) Any user can read resources.
     * @allow (create) User can create a resource if the authorId matches their user ID.
     * @allow (update, delete) Only the author of the resource can update or delete it, and only if the resource exists.
     * @deny (create) User cannot create a resource with an authorId that doesn't match their own user ID.
     * @deny (update, delete) User cannot update or delete a resource they did not create.
     * @principle Enforces document ownership for writes, allows public reads.
     */
    match /resources/{resourceId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && request.resource.data.authorId == getAfter().data.authorId && request.auth.uid == getAfter().data.authorId;
      allow delete: if isSignedIn() && request.auth.uid == getAfter().data.authorId;
    }

    /**
     * @description Controls access to bootcamp information.
     * @path /bootcamps/{bootcampId}
     * @allow (get, list) Any user can read bootcamp information.
     * @deny (create, update, delete) Only specific logic should allow modification of bootcamp information (TODO).
     * @principle Public read access with restricted write access.
     */
    match /bootcamps/{bootcampId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add logic for bootcamp management
    }

    /**
     * @description Controls access to admin roles.
     * @path /roles_admin/{userId}
     * @allow create: if isAdmin();
     * @allow get: if isAdmin();
     * @allow list: if isAdmin();
     * @allow update: if isAdmin();
     * @allow delete: if isAdmin();
     * @principle Only admins can create, read, update, or delete admin roles.
     */
    match /roles_admin/{userId} {
      allow create: if isAdmin();
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }
  }

  // Helper Functions
  function isSignedIn() {
    return request.auth != null;
  }

  function isOwner(userId) {
    return request.auth.uid == userId;
  }

  function isExistingOwner(userId) {
      return isSignedIn() && isOwner(userId);
  }

  function isAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
  }

    function getAfter() {
      return get(/databases/$(database)/documents/resources/$(resourceId));
    }
}